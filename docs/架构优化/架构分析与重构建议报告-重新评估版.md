# ESP32-S3 PawCounter è®¡ç®—å™¨é¡¹ç›®æ¶æ„åˆ†æä¸é‡æ„å»ºè®®æŠ¥å‘Š - é‡æ–°è¯„ä¼°ç‰ˆ

## æ‰§è¡Œæ‘˜è¦

æœ¬æŠ¥å‘ŠåŸºäºå¯¹PawCounteré¡¹ç›®çš„æ·±å…¥åˆ†æï¼Œé‡æ–°è¯„ä¼°äº†é’ˆå¯¹TOCé”®ç›˜åœˆå­å’Œé«˜å¼ºåº¦è®¡ç®—å™¨ç”¨æˆ·çš„æ¶æ„éœ€æ±‚ã€‚ç»è¿‡å…¨é¢çš„ä»£ç å®¡æŸ¥å’Œç”¨æˆ·éœ€æ±‚åˆ†æï¼Œæˆ‘ä»¬å‘ç°åŸæŠ¥å‘Šå¯¹æŸäº›å…³é”®åŠŸèƒ½çš„è¯„ä¼°å­˜åœ¨åå·®ï¼Œç‰¹åˆ«æ˜¯æ—¥å¿—ç³»ç»Ÿã€æµ‹è¯•ç³»ç»Ÿã€æŒä¹…åŒ–é…ç½®å’Œé’¢ç´éŸ³æ•ˆæ¨¡å‹ç­‰æå®¢å¼€å‘åŠŸèƒ½çš„é‡è¦æ€§è¢«ä½ä¼°ã€‚æœ¬æŠ¥å‘Šæä¾›äº†æ›´åŠ ç²¾å‡†çš„æ¶æ„ä¼˜åŒ–å»ºè®®ï¼Œæ—¢ä¿æŒäº†äº§å“çš„æ ¸å¿ƒç«äº‰åŠ›ï¼Œåˆæå‡äº†ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

## ç›®å½•

1. [é¡¹ç›®é‡æ–°å®šä½](#é¡¹ç›®é‡æ–°å®šä½)
2. [ç›®æ ‡ç”¨æˆ·ç¾¤ä½“åˆ†æ](#ç›®æ ‡ç”¨æˆ·ç¾¤ä½“åˆ†æ)
3. [æ ¸å¿ƒåŠŸèƒ½ä»·å€¼é‡è¯„ä¼°](#æ ¸å¿ƒåŠŸèƒ½ä»·å€¼é‡è¯„ä¼°)
4. [æ¶æ„ä¼˜åŒ–å»ºè®®](#æ¶æ„ä¼˜åŒ–å»ºè®®)
5. [å®æ–½è·¯çº¿å›¾](#å®æ–½è·¯çº¿å›¾)
6. [ç»“è®º](#ç»“è®º)

## é¡¹ç›®é‡æ–°å®šä½

### äº§å“å®šä½
PawCounteræ˜¯ä¸€ä¸ªé¢å‘**TOCé”®ç›˜åœˆå­**å’Œ**é«˜å¼ºåº¦è®¡ç®—å™¨ç”¨æˆ·**çš„ä¸“ä¸šçº§åµŒå…¥å¼è®¡ç®—å™¨ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒç‰¹å¾ï¼š

- **æå®¢å‹å¥½**: æä¾›ä¸°å¯Œçš„å¼€å‘å’Œè°ƒè¯•åŠŸèƒ½
- **ç”¨æˆ·ä½“éªŒä¼˜å…ˆ**: é’¢ç´éŸ³æ•ˆã€LEDåé¦ˆã€è§¦è§‰ä½“éªŒ
- **é«˜åº¦å¯å®šåˆ¶**: æ”¯æŒè¯¦ç»†çš„é…ç½®å‚æ•°å’Œä¸ªæ€§åŒ–è®¾ç½®
- **ä¸“ä¸šçº§ç¨³å®šæ€§**: å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿå’Œæµ‹è¯•æ¡†æ¶
- **ç°ä»£åŒ–æ¶æ„**: åŸºäºESP32-S3çš„é«˜æ€§èƒ½å®ç°

### ç«äº‰ä¼˜åŠ¿
1. **ç‹¬ç‰¹çš„é’¢ç´éŸ³æ•ˆç³»ç»Ÿ**: 22ä¸ªæŒ‰é”®å¯¹åº”ä¸åŒéŸ³é˜¶ï¼Œæä¾›å¬è§‰åé¦ˆ
2. **ä¸“ä¸šçº§é…ç½®ç®¡ç†**: æ”¯æŒ62ä¸ªé…ç½®å‚æ•°çš„ç²¾ç»†è°ƒèŠ‚
3. **å¼€å‘è€…å‹å¥½**: å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿå’Œä¸²å£å‘½ä»¤æ¥å£
4. **åŒåŠŸèƒ½è®¾è®¡**: åŒæ—¶æ”¯æŒè®¡ç®—å™¨å’ŒUSB HIDé”®ç›˜åŠŸèƒ½

## ç›®æ ‡ç”¨æˆ·ç¾¤ä½“åˆ†æ

### TOCé”®ç›˜åœˆå­ç”¨æˆ·ç‰¹å¾
- **è¿½æ±‚æè‡´ä½“éªŒ**: å¯¹é”®ç›˜æ‰‹æ„Ÿã€éŸ³æ•ˆã€LEDåé¦ˆæœ‰å¾ˆé«˜è¦æ±‚
- **çƒ­è¡·å®šåˆ¶åŒ–**: å–œæ¬¢è°ƒèŠ‚å„ç§å‚æ•°ä»¥è·å¾—ä¸ªæ€§åŒ–ä½“éªŒ
- **æŠ€æœ¯æ•æ„Ÿ**: æ¬£èµæŠ€æœ¯å®ç°çš„ç²¾å·§å’Œåˆ›æ–°
- **ç¤¾åŒºé©±åŠ¨**: æ„¿æ„åˆ†äº«ä½¿ç”¨å¿ƒå¾—å’Œæ”¹è¿›å»ºè®®

### é«˜å¼ºåº¦è®¡ç®—å™¨ç”¨æˆ·ç‰¹å¾
- **å‡†ç¡®æ€§è¦æ±‚**: å¯¹è®¡ç®—ç²¾åº¦å’Œç¨³å®šæ€§æœ‰ä¸¥æ ¼è¦æ±‚
- **æ•ˆç‡å¯¼å‘**: éœ€è¦å¿«é€Ÿå“åº”å’Œç›´è§‚çš„æ“ä½œç•Œé¢
- **åŠŸèƒ½å…¨é¢**: éœ€è¦å†å²è®°å½•ã€å¤šç§è¿ç®—æ¨¡å¼ç­‰ä¸“ä¸šåŠŸèƒ½
- **å¯é æ€§**: è¦æ±‚è®¾å¤‡é•¿æœŸç¨³å®šè¿è¡Œ

### æå®¢å¼€å‘è€…ç‰¹å¾
- **å–œæ¬¢æ¢ç´¢**: å¯¹è®¾å¤‡å†…éƒ¨å·¥ä½œåŸç†æ„Ÿå…´è¶£
- **è‡ªå®šä¹‰èƒ½åŠ›**: å¸Œæœ›èƒ½å¤Ÿä¿®æ”¹å’Œæ‰©å±•åŠŸèƒ½
- **è°ƒè¯•éœ€æ±‚**: éœ€è¦æ—¥å¿—ç³»ç»Ÿå’Œæµ‹è¯•å·¥å…·
- **å¼€æºç²¾ç¥**: æ¬£èµå¼€æ”¾çš„æ¶æ„è®¾è®¡

## æ ¸å¿ƒåŠŸèƒ½ä»·å€¼è¯„ä¼°

### 1. æ—¥å¿—ç³»ç»Ÿ (Logger) - æ ¸å¿ƒå¿…è¦åŠŸèƒ½

#### é‡è¦æ€§åˆ†æ
- **å¼€å‘è°ƒè¯•**: é¢å‘æå®¢ç”¨æˆ·ï¼Œæ—¥å¿—ç³»ç»Ÿæ˜¯å¿…éœ€çš„è°ƒè¯•å·¥å…·
- **é—®é¢˜è¯Šæ–­**: ç”¨æˆ·é‡åˆ°é—®é¢˜æ—¶ï¼Œæ—¥å¿—æä¾›é‡è¦çš„è¯Šæ–­ä¿¡æ¯
- **æ€§èƒ½ç›‘æ§**: å¸®åŠ©è¯†åˆ«æ€§èƒ½ç“¶é¢ˆå’Œä¼˜åŒ–æœºä¼š
- **ç”¨æˆ·åé¦ˆ**: ç”¨æˆ·å¯ä»¥é€šè¿‡æ—¥å¿—å‘å¼€å‘è€…åé¦ˆé—®é¢˜

#### ä¼˜åŒ–å»ºè®®
```cpp
// ä¿ç•™å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿï¼Œä½†ä¼˜åŒ–å®ç°
class Logger {
    // ç”Ÿäº§ç¯å¢ƒå¯é…ç½®æ€§èƒ½ä¼˜åŒ–
    static void optimizeForProduction() {
        // å‡å°‘å†…å­˜å ç”¨
        setBufferSize(512);  // ç”Ÿäº§ç¯å¢ƒå‡å°‘ç¼“å†²åŒº
        // ä»…ä¿ç•™å…³é”®æ—¥å¿—çº§åˆ«
        setLevel(LOG_LEVEL_WARN);
    }
    
    // å¼€å‘ç¯å¢ƒå®Œæ•´åŠŸèƒ½
    static void enableDevelopmentMode() {
        setLevel(LOG_LEVEL_DEBUG);
        enableColorOutput(true);
        enableTimestamp(true);
    }
};
```

### 2. æµ‹è¯•ç³»ç»Ÿ - å»ºç«‹å®Œæ•´çš„æµ‹è¯•ç³»ç»Ÿ

#### å»ºè®®å®ç°
```cpp
// å»ºè®®æ·»åŠ æ ¸å¿ƒç»„ä»¶å•å…ƒæµ‹è¯•
class CalculationEngineTest {
    static void runAllTests() {
        testBasicArithmetic();
        testPrecisionCalculation();
        testErrorHandling();
        testMemoryOperations();
    }
    
    static void testBasicArithmetic() {
        CalculationEngine engine;
        assert(engine.add(2.5, 3.7) == 6.2);
        assert(engine.multiply(1.5, 2.0) == 3.0);
        LOG_I("TEST", "åŸºç¡€è¿ç®—æµ‹è¯•é€šè¿‡");
    }
};
```

### 3. æŒä¹…åŒ–é…ç½®ç³»ç»Ÿ - ä¿æŒç°æœ‰é…ç½®ç³»ç»Ÿ

#### é‡è¦æ€§åˆ†æ
- **ç”¨æˆ·ä½“éªŒ**: TOCç”¨æˆ·éœ€è¦ç»†è‡´çš„ä¸ªæ€§åŒ–è®¾ç½®
- **äº§å“å·®å¼‚åŒ–**: ä¸°å¯Œçš„é…ç½®é€‰é¡¹æ˜¯äº§å“ç«äº‰åŠ›
- **åŠŸèƒ½å®Œæ•´æ€§**: æ”¯æŒå¤šç§ä½¿ç”¨åœºæ™¯å’Œç”¨æˆ·åå¥½

#### å½“å‰é…ç½®é¡¹ç›®åˆ†æ
```cpp
struct PersistentConfig {
    // LEDé…ç½® (2é¡¹) - å¿…è¦
    uint8_t globalBrightness;
    uint16_t ledFadeDuration;
    
    // èœ‚é¸£å™¨é…ç½® (7é¡¹) - é’¢ç´éŸ³æ•ˆæ ¸å¿ƒåŠŸèƒ½
    bool buzzerEnabled;
    bool buzzerFollowKeypress;
    bool buzzerDualTone;
    uint8_t buzzerMode;        // æ™®é€š/é’¢ç´æ¨¡å¼
    uint8_t buzzerVolume;
    uint16_t buzzerPressFreq;
    uint16_t buzzerReleaseFreq;
    uint16_t buzzerDuration;
    
    // æŒ‰é”®é…ç½® (3é¡¹) - ç”¨æˆ·ä½“éªŒå¿…è¦
    uint16_t repeatDelay;
    uint16_t repeatRate;
    uint16_t longPressDelay;
    
    // ç³»ç»Ÿé…ç½® (5é¡¹) - ç³»ç»Ÿç¨³å®šæ€§å¿…è¦
    uint8_t backlightBrightness;
    uint32_t sleepTimeout;
    bool autoSave;
    bool logEnabled;
    uint8_t logLevel;
};
```

**ç»“è®º**: å½“å‰17ä¸ªæ ¸å¿ƒé…ç½®é¡¹éƒ½æ˜¯å¿…è¦çš„ï¼Œä¸å»ºè®®å‡å°‘ã€‚

### 4. é’¢ç´éŸ³æ•ˆæ¨¡å‹ - æ ¸å¿ƒå·®å¼‚åŒ–åŠŸèƒ½

#### é‡è¦æ€§åˆ†æ
- **å“ç‰Œç‰¹è‰²**: é’¢ç´éŸ³æ•ˆæ˜¯äº§å“çš„ç‹¬ç‰¹å–ç‚¹
- **ç”¨æˆ·ä½“éªŒ**: æä¾›ä¸°å¯Œçš„å¬è§‰åé¦ˆå’Œå¨±ä¹åŠŸèƒ½
- **æŠ€æœ¯å±•ç¤º**: å±•ç¤ºäº§å“çš„æŠ€æœ¯å®ç°æ°´å¹³
- **ç¤¾åŒºä»·å€¼**: TOCç”¨æˆ·ä¼šå› ä¸ºè¿™ä¸ªåŠŸèƒ½è€Œé€‰æ‹©äº§å“

#### æŠ€æœ¯å®ç°ä¼˜åŠ¿
```cpp
// ç²¾å¿ƒè®¾è®¡çš„éŸ³é˜¶ç³»ç»Ÿ
const uint16_t PIANO_TONES[22] = {
    500,  540,  583,  629,  679,  733,  791,  854,  922,  995,   // ä½éŸ³-ä¸­éŸ³
    1074, 1159, 1252, 1351, 1459, 1575, 1700, 1836, 1982, 2140, // ä¸­é«˜éŸ³-å¾ˆé«˜éŸ³
    2310, 2500  // è¶…é«˜éŸ³
};

// 5å€é¢‘ç‡èŒƒå›´ï¼Œç­‰æ¯”æ•°åˆ—åˆ†å¸ƒï¼ŒéŸ³è°ƒæ¸…æ™°å¯è¾¨
// ä¸“é—¨é’ˆå¯¹èœ‚é¸£å™¨ç¡¬ä»¶ä¼˜åŒ–çš„é¢‘ç‡é€‰æ‹©
```

### 5. FontTester - ä¿ç•™ä½œä¸ºå¼€å‘å·¥å…·

#### é‡è¦æ€§åˆ†æ
- **å¼€å‘è¾…åŠ©**: å¯¹äºç»´æŠ¤å’Œæ‰©å±•å­—ä½“åŠŸèƒ½å¾ˆæœ‰å¸®åŠ©
- **ç”¨æˆ·æ”¯æŒ**: ç”¨æˆ·å¯ä»¥æµ‹è¯•å­—ä½“æ˜¾ç¤ºæ•ˆæœ
- **å ç”¨è¾ƒå°**: ä»…123è¡Œä»£ç ï¼Œå ç”¨èµ„æºå¾ˆå°‘

#### ä¼˜åŒ–å»ºè®®
```cpp
// æ¡ä»¶ç¼–è¯‘ï¼Œå‘å¸ƒç‰ˆæœ¬å¯é€‰æ‹©æ€§ç§»é™¤
#ifdef ENABLE_FONT_TESTER
    fontTester = std::make_unique<FontTester>();
#endif
```

## æ¶æ„ä¼˜åŒ–å»ºè®®

### é˜¶æ®µ1: ä»£ç ç»“æ„ä¼˜åŒ– + FreeRTOSå¤šä»»åŠ¡è°ƒåº¦ (ä¼˜å…ˆçº§: ğŸ”´ é«˜)

#### 1.1 FreeRTOSä»»åŠ¡ç³»ç»Ÿæ¶æ„

**è®¾è®¡åŸåˆ™**:
- é«˜ä¼˜å…ˆçº§ä»»åŠ¡å¤„ç†ç”¨æˆ·äº¤äº’ï¼ˆæŒ‰é”®ã€æ˜¾ç¤ºï¼‰
- ä¸­ç­‰ä¼˜å…ˆçº§ä»»åŠ¡å¤„ç†è®¡ç®—é€»è¾‘
- ä½ä¼˜å…ˆçº§ä»»åŠ¡å¤„ç†ç³»ç»Ÿç®¡ç†ï¼ˆé…ç½®ã€æ—¥å¿—ã€çœç”µï¼‰

**ä»»åŠ¡ä¼˜å…ˆçº§åˆ†é…**:
```cpp
// ä»»åŠ¡ä¼˜å…ˆçº§å®šä¹‰
#define TASK_PRIORITY_KEYPAD     3  // æœ€é«˜ä¼˜å…ˆçº§ - æŒ‰é”®å“åº”
#define TASK_PRIORITY_DISPLAY    2  // ä¸­ç­‰ä¼˜å…ˆçº§ - æ˜¾ç¤ºæ›´æ–°
#define TASK_PRIORITY_SYSTEM     1  // ä½ä¼˜å…ˆçº§ - ç³»ç»Ÿç®¡ç†
#define TASK_PRIORITY_IDLE       0  // ç©ºé—²ä»»åŠ¡

// ä»»åŠ¡å †æ ˆå¤§å°
#define STACK_SIZE_KEYPAD        4096
#define STACK_SIZE_DISPLAY       4096
#define STACK_SIZE_SYSTEM        2048
```

#### 1.2 ä¸»æ–‡ä»¶é‡æ„ (FreeRTOSç‰ˆæœ¬)
**ç›®æ ‡**: å°†main.cppä»764è¡Œå‡å°‘åˆ°200è¡Œä»¥ä¸‹ï¼Œå¼•å…¥å¤šä»»åŠ¡è°ƒåº¦

```cpp
// main.cpp (< 200è¡Œ)
#include <Arduino.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <freertos/semphr.h>
#include "SystemController.h"
#include "CalculatorApplication.h"
#include "TaskManager.h"

// å…¨å±€ä»»åŠ¡ç®¡ç†å™¨
TaskManager taskManager;

void setup() {
    Serial.begin(115200);
    
    // åˆå§‹åŒ–ç¡¬ä»¶å’ŒåŸºç¡€ç³»ç»Ÿ
    taskManager.initializeHardware();
    
    // åˆ›å»ºFreeRTOSä»»åŠ¡
    taskManager.createTasks();
    
    // å¯åŠ¨è°ƒåº¦å™¨
    Serial.println("å¯åŠ¨FreeRTOSä»»åŠ¡è°ƒåº¦å™¨...");
    // æ³¨æ„ï¼švTaskStartScheduler()åä¸ä¼šè¿”å›
}

void loop() {
    // FreeRTOSæ¥ç®¡åï¼Œloop()ä¸ä¼šè¢«è°ƒç”¨
    // æ‰€æœ‰é€»è¾‘éƒ½åœ¨ä»»åŠ¡ä¸­æ‰§è¡Œ
}
```

#### 1.3 ä»»åŠ¡ç®¡ç†å™¨å®ç°

```cpp
// TaskManager.h
class TaskManager {
public:
    bool initializeHardware();
    void createTasks();
    
    // ä»»åŠ¡é—´é€šä¿¡
    QueueHandle_t getKeyEventQueue() { return keyEventQueue; }
    QueueHandle_t getDisplayUpdateQueue() { return displayUpdateQueue; }
    SemaphoreHandle_t getConfigMutex() { return configMutex; }
    
private:
    // ä»»åŠ¡å¥æŸ„
    TaskHandle_t keypadTaskHandle;
    TaskHandle_t displayTaskHandle;
    TaskHandle_t systemTaskHandle;
    
    // ä»»åŠ¡é—´é€šä¿¡
    QueueHandle_t keyEventQueue;
    QueueHandle_t displayUpdateQueue;
    SemaphoreHandle_t configMutex;
    
    // ä»»åŠ¡å‡½æ•°
    static void keypadTask(void* parameter);
    static void displayTask(void* parameter);
    static void systemTask(void* parameter);
    
    // ç»„ä»¶ç®¡ç†
    std::unique_ptr<SystemController> systemController;
    std::unique_ptr<CalculatorApplication> calculatorApp;
};
```

#### 1.4 ä»»åŠ¡å®ç°ç»†èŠ‚

```cpp
// TaskManager.cpp
void TaskManager::createTasks() {
    // åˆ›å»ºä»»åŠ¡é—´é€šä¿¡å¯¹è±¡
    keyEventQueue = xQueueCreate(10, sizeof(KeyEvent));
    displayUpdateQueue = xQueueCreate(5, sizeof(DisplayUpdate));
    configMutex = xSemaphoreCreateMutex();
    
    // åˆ›å»ºé«˜ä¼˜å…ˆçº§æŒ‰é”®ä»»åŠ¡
    xTaskCreatePinnedToCore(
        keypadTask,
        "KeypadTask",
        STACK_SIZE_KEYPAD,
        this,
        TASK_PRIORITY_KEYPAD,
        &keypadTaskHandle,
        1  // ç»‘å®šåˆ°æ ¸å¿ƒ1
    );
    
    // åˆ›å»ºæ˜¾ç¤ºä»»åŠ¡
    xTaskCreatePinnedToCore(
        displayTask,
        "DisplayTask",
        STACK_SIZE_DISPLAY,
        this,
        TASK_PRIORITY_DISPLAY,
        &displayTaskHandle,
        1  // ç»‘å®šåˆ°æ ¸å¿ƒ1
    );
    
    // åˆ›å»ºç³»ç»Ÿç®¡ç†ä»»åŠ¡
    xTaskCreatePinnedToCore(
        systemTask,
        "SystemTask",
        STACK_SIZE_SYSTEM,
        this,
        TASK_PRIORITY_SYSTEM,
        &systemTaskHandle,
        0  // ç»‘å®šåˆ°æ ¸å¿ƒ0
    );
}

// æŒ‰é”®ä»»åŠ¡ - æœ€é«˜ä¼˜å…ˆçº§
void TaskManager::keypadTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    KeyEvent keyEvent;
    
    while (true) {
        // æ‰«ææŒ‰é”®ï¼Œ10mså‘¨æœŸ
        self->calculatorApp->updateKeypad();
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‰é”®äº‹ä»¶
        if (self->calculatorApp->getKeyEvent(&keyEvent)) {
            // å‘é€æŒ‰é”®äº‹ä»¶åˆ°é˜Ÿåˆ—
            xQueueSend(self->keyEventQueue, &keyEvent, 0);
        }
        
        // æ›´æ–°LEDæ•ˆæœ
        self->calculatorApp->updateLEDs();
        
        vTaskDelay(pdMS_TO_TICKS(10));  // 10mså»¶æ—¶
    }
}

// æ˜¾ç¤ºä»»åŠ¡ - ä¸­ç­‰ä¼˜å…ˆçº§
void TaskManager::displayTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    KeyEvent keyEvent;
    DisplayUpdate displayUpdate;
    
    while (true) {
        // å¤„ç†æŒ‰é”®äº‹ä»¶
        if (xQueueReceive(self->keyEventQueue, &keyEvent, pdMS_TO_TICKS(5))) {
            // å¤„ç†æŒ‰é”®é€»è¾‘
            self->calculatorApp->handleKeyEvent(keyEvent);
        }
        
        // æ›´æ–°æ˜¾ç¤º
        self->calculatorApp->updateDisplay();
        
        // å¤„ç†LVGLå®šæ—¶å™¨
        lv_timer_handler();
        
        vTaskDelay(pdMS_TO_TICKS(20));  // 20mså»¶æ—¶ï¼Œ50fps
    }
}

// ç³»ç»Ÿä»»åŠ¡ - ä½ä¼˜å…ˆçº§
void TaskManager::systemTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    
    while (true) {
        // å¤„ç†ä¸²å£å‘½ä»¤
        self->systemController->handleSerialCommands();
        
        // æ›´æ–°ä¼‘çœ ç®¡ç†
        self->systemController->updateSleepManager();
        
        // é…ç½®è‡ªåŠ¨ä¿å­˜
        if (xSemaphoreTake(self->configMutex, pdMS_TO_TICKS(100))) {
            self->systemController->saveConfigIfDirty();
            xSemaphoreGive(self->configMutex);
        }
        
        // ç³»ç»Ÿç›‘æ§å’Œæ—¥å¿—
        self->systemController->systemMonitoring();
        
        vTaskDelay(pdMS_TO_TICKS(1000));  // 1ç§’å»¶æ—¶
    }
}
```

#### 1.5 ç»„ä»¶æ¥å£é‡æ„

```cpp
// SystemController.h - ç³»ç»Ÿçº§ç®¡ç†
class SystemController {
public:
    bool initialize();
    void handleSerialCommands();
    void updateSleepManager();
    void saveConfigIfDirty();
    void systemMonitoring();
    
    // çº¿ç¨‹å®‰å…¨æ¥å£
    bool getConfigValue(const String& key, String& value);
    bool setConfigValue(const String& key, const String& value);
    
private:
    std::unique_ptr<ConfigManager> configManager;
    std::unique_ptr<Logger> logger;
    std::unique_ptr<SleepManager> sleepManager;
    
    // çº¿ç¨‹å®‰å…¨æ ‡å¿—
    bool configDirty = false;
    unsigned long lastConfigSave = 0;
};

// CalculatorApplication.h - åº”ç”¨çº§é€»è¾‘
class CalculatorApplication {
public:
    bool initialize();
    void updateKeypad();
    void updateLEDs();
    void updateDisplay();
    void handleKeyEvent(const KeyEvent& event);
    bool getKeyEvent(KeyEvent* event);
    
private:
    std::unique_ptr<CalculatorCore> calculator;
    std::unique_ptr<LVGLDisplay> display;
    std::unique_ptr<KeypadControl> keypad;
    std::unique_ptr<SimpleHID> hid;
    
    // äº‹ä»¶ç¼“å†²åŒº
    std::queue<KeyEvent> keyEventBuffer;
};
```

#### 1.6 æ•°æ®ç»“æ„å®šä¹‰

```cpp
// æŒ‰é”®äº‹ä»¶ç»“æ„
struct KeyEvent {
    KeyEventType type;
    uint8_t key;
    uint8_t combo[5];
    uint8_t comboCount;
    uint32_t timestamp;
};

// æ˜¾ç¤ºæ›´æ–°ç»“æ„
struct DisplayUpdate {
    enum Type {
        EXPRESSION_UPDATE,
        RESULT_UPDATE,
        HISTORY_UPDATE,
        FULL_REFRESH
    } type;
    String data;
    bool forceUpdate;
};

// é…ç½®æ›´æ–°ç»“æ„
struct ConfigUpdate {
    String key;
    String value;
    bool persistent;
};
```

#### 1.7 æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§

```cpp
// åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´
class TaskManager {
    void adjustTaskPriorities() {
        // æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´ä»»åŠ¡ä¼˜å…ˆçº§
        if (isHighFrequencyCalculation()) {
            vTaskPrioritySet(displayTaskHandle, TASK_PRIORITY_DISPLAY + 1);
        } else {
            vTaskPrioritySet(displayTaskHandle, TASK_PRIORITY_DISPLAY);
        }
    }
    
    // ä»»åŠ¡ç›‘æ§
    void monitorTaskPerformance() {
        TaskStatus_t taskStatus;
        vTaskGetInfo(keypadTaskHandle, &taskStatus, pdTRUE, eInvalid);
        
        // è®°å½•ä»»åŠ¡CPUä½¿ç”¨ç‡
        float cpuUsage = (float)taskStatus.ulRunTimeCounter / totalRunTime * 100;
        LOG_D("TASK", "æŒ‰é”®ä»»åŠ¡CPUä½¿ç”¨ç‡: %.1f%%", cpuUsage);
    }
};
```

#### 1.8 é”™è¯¯å¤„ç†å’Œæ¢å¤

```cpp
// ä»»åŠ¡çœ‹é—¨ç‹—
class TaskWatchdog {
    void init() {
        esp_task_wdt_init(30, true);  // 30ç§’è¶…æ—¶
        esp_task_wdt_add(NULL);       // æ·»åŠ å½“å‰ä»»åŠ¡
    }
    
    void feedWatchdog() {
        esp_task_wdt_reset();
    }
};

// ä»»åŠ¡å´©æºƒæ¢å¤
void TaskManager::taskCrashHandler(TaskHandle_t crashedTask) {
    LOG_E("TASK", "ä»»åŠ¡å´©æºƒï¼Œå°è¯•é‡å¯");
    
    // è®°å½•å´©æºƒä¿¡æ¯
    saveCrashInfo(crashedTask);
    
    // é‡å¯å¯¹åº”ä»»åŠ¡
    if (crashedTask == keypadTaskHandle) {
        vTaskDelete(keypadTaskHandle);
        xTaskCreate(keypadTask, "KeypadTask", STACK_SIZE_KEYPAD, 
                   this, TASK_PRIORITY_KEYPAD, &keypadTaskHandle);
    }
}
```

### é˜¶æ®µ2: ä»£ç å®ç°æŒ‡å—

#### 2.1 æ–‡ä»¶ç»“æ„é‡ç»„

**æ–°å¢æ–‡ä»¶ç»“æ„**:
```
src/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ TaskManager.cpp
â”‚   â”œâ”€â”€ TaskManager.h
â”‚   â”œâ”€â”€ SystemController.cpp
â”‚   â”œâ”€â”€ SystemController.h
â”‚   â”œâ”€â”€ CalculatorApplication.cpp
â”‚   â””â”€â”€ CalculatorApplication.h
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ KeypadTask.cpp
â”‚   â”œâ”€â”€ KeypadTask.h
â”‚   â”œâ”€â”€ DisplayTask.cpp
â”‚   â”œâ”€â”€ DisplayTask.h
â”‚   â”œâ”€â”€ SystemTask.cpp
â”‚   â””â”€â”€ SystemTask.h
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ TaskWatchdog.cpp
â”‚   â”œâ”€â”€ TaskWatchdog.h
â”‚   â”œâ”€â”€ MemoryManager.cpp
â”‚   â””â”€â”€ MemoryManager.h
â””â”€â”€ main.cpp (é‡æ„å)
```

#### 2.2 å…³é”®ç»„ä»¶å®ç°

**TaskManager.cpp å®Œæ•´å®ç°**:
```cpp
#include "TaskManager.h"
#include "Logger.h"
#include "esp_task_wdt.h"

TaskManager::TaskManager() : 
    keyEventQueue(nullptr),
    displayUpdateQueue(nullptr),
    configMutex(nullptr),
    keypadTaskHandle(nullptr),
    displayTaskHandle(nullptr),
    systemTaskHandle(nullptr) {
}

bool TaskManager::initializeHardware() {
    LOG_I("TASK", "å¼€å§‹ç¡¬ä»¶åˆå§‹åŒ–");
    
    // åˆå§‹åŒ–ç³»ç»Ÿæ§åˆ¶å™¨
    systemController = std::make_unique<SystemController>();
    if (!systemController->initialize()) {
        LOG_E("TASK", "ç³»ç»Ÿæ§åˆ¶å™¨åˆå§‹åŒ–å¤±è´¥");
        return false;
    }
    
    // åˆå§‹åŒ–è®¡ç®—å™¨åº”ç”¨
    calculatorApp = std::make_unique<CalculatorApplication>();
    if (!calculatorApp->initialize()) {
        LOG_E("TASK", "è®¡ç®—å™¨åº”ç”¨åˆå§‹åŒ–å¤±è´¥");
        return false;
    }
    
    // åˆå§‹åŒ–çœ‹é—¨ç‹—
    taskWatchdog = std::make_unique<TaskWatchdog>();
    taskWatchdog->init();
    
    LOG_I("TASK", "ç¡¬ä»¶åˆå§‹åŒ–å®Œæˆ");
    return true;
}

void TaskManager::createTasks() {
    LOG_I("TASK", "åˆ›å»ºFreeRTOSä»»åŠ¡");
    
    // åˆ›å»ºä»»åŠ¡é—´é€šä¿¡å¯¹è±¡
    keyEventQueue = xQueueCreate(KEY_EVENT_QUEUE_SIZE, sizeof(KeyEvent));
    displayUpdateQueue = xQueueCreate(DISPLAY_UPDATE_QUEUE_SIZE, sizeof(DisplayUpdate));
    configMutex = xSemaphoreCreateMutex();
    
    if (!keyEventQueue || !displayUpdateQueue || !configMutex) {
        LOG_E("TASK", "åˆ›å»ºä»»åŠ¡é€šä¿¡å¯¹è±¡å¤±è´¥");
        return;
    }
    
    // åˆ›å»ºæŒ‰é”®ä»»åŠ¡ (æœ€é«˜ä¼˜å…ˆçº§)
    BaseType_t result = xTaskCreatePinnedToCore(
        keypadTask,
        "KeypadTask",
        STACK_SIZE_KEYPAD,
        this,
        TASK_PRIORITY_KEYPAD,
        &keypadTaskHandle,
        APP_CPU_NUM
    );
    
    if (result != pdPASS) {
        LOG_E("TASK", "åˆ›å»ºæŒ‰é”®ä»»åŠ¡å¤±è´¥");
        return;
    }
    
    // åˆ›å»ºæ˜¾ç¤ºä»»åŠ¡ (ä¸­ç­‰ä¼˜å…ˆçº§)
    result = xTaskCreatePinnedToCore(
        displayTask,
        "DisplayTask",
        STACK_SIZE_DISPLAY,
        this,
        TASK_PRIORITY_DISPLAY,
        &displayTaskHandle,
        APP_CPU_NUM
    );
    
    if (result != pdPASS) {
        LOG_E("TASK", "åˆ›å»ºæ˜¾ç¤ºä»»åŠ¡å¤±è´¥");
        return;
    }
    
    // åˆ›å»ºç³»ç»Ÿä»»åŠ¡ (ä½ä¼˜å…ˆçº§)
    result = xTaskCreatePinnedToCore(
        systemTask,
        "SystemTask",
        STACK_SIZE_SYSTEM,
        this,
        TASK_PRIORITY_SYSTEM,
        &systemTaskHandle,
        PRO_CPU_NUM
    );
    
    if (result != pdPASS) {
        LOG_E("TASK", "åˆ›å»ºç³»ç»Ÿä»»åŠ¡å¤±è´¥");
        return;
    }
    
    LOG_I("TASK", "æ‰€æœ‰ä»»åŠ¡åˆ›å»ºå®Œæˆ");
}

// æŒ‰é”®ä»»åŠ¡å®ç°
void TaskManager::keypadTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    KeyEvent keyEvent;
    TickType_t lastWakeTime = xTaskGetTickCount();
    
    LOG_I("KEYPAD", "æŒ‰é”®ä»»åŠ¡å¯åŠ¨");
    
    while (true) {
        // å–‚ç‹—
        self->taskWatchdog->feedWatchdog();
        
        // æ‰«ææŒ‰é”®çŸ©é˜µ
        self->calculatorApp->scanKeypadMatrix();
        
        // å¤„ç†æŒ‰é”®äº‹ä»¶
        while (self->calculatorApp->getKeyEvent(&keyEvent)) {
            // æ·»åŠ æ—¶é—´æˆ³
            keyEvent.timestamp = xTaskGetTickCount();
            
            // å‘é€åˆ°äº‹ä»¶é˜Ÿåˆ—
            if (xQueueSend(self->keyEventQueue, &keyEvent, 0) != pdTRUE) {
                LOG_W("KEYPAD", "æŒ‰é”®äº‹ä»¶é˜Ÿåˆ—æ»¡");
            }
        }
        
        // æ›´æ–°LEDæ•ˆæœ
        self->calculatorApp->updateLEDEffects();
        
        // å¤„ç†èœ‚é¸£å™¨
        self->calculatorApp->updateBuzzer();
        
        // ç²¾ç¡®å®šæ—¶ï¼Œ10mså‘¨æœŸ
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(10));
    }
}

// æ˜¾ç¤ºä»»åŠ¡å®ç°
void TaskManager::displayTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    KeyEvent keyEvent;
    DisplayUpdate displayUpdate;
    TickType_t lastWakeTime = xTaskGetTickCount();
    
    LOG_I("DISPLAY", "æ˜¾ç¤ºä»»åŠ¡å¯åŠ¨");
    
    while (true) {
        // å–‚ç‹—
        self->taskWatchdog->feedWatchdog();
        
        // å¤„ç†æŒ‰é”®äº‹ä»¶
        while (xQueueReceive(self->keyEventQueue, &keyEvent, 0) == pdTRUE) {
            self->calculatorApp->handleKeyEvent(keyEvent);
        }
        
        // å¤„ç†æ˜¾ç¤ºæ›´æ–°
        while (xQueueReceive(self->displayUpdateQueue, &displayUpdate, 0) == pdTRUE) {
            self->calculatorApp->handleDisplayUpdate(displayUpdate);
        }
        
        // æ›´æ–°æ˜¾ç¤º
        self->calculatorApp->updateDisplay();
        
        // å¤„ç†LVGLå®šæ—¶å™¨
        lv_timer_handler();
        
        // 20mså‘¨æœŸï¼Œ50fps
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(20));
    }
}

// ç³»ç»Ÿä»»åŠ¡å®ç°
void TaskManager::systemTask(void* parameter) {
    TaskManager* self = static_cast<TaskManager*>(parameter);
    TickType_t lastWakeTime = xTaskGetTickCount();
    uint32_t cycleCount = 0;
    
    LOG_I("SYSTEM", "ç³»ç»Ÿä»»åŠ¡å¯åŠ¨");
    
    while (true) {
        // å–‚ç‹—
        self->taskWatchdog->feedWatchdog();
        
        // å¤„ç†ä¸²å£å‘½ä»¤
        self->systemController->processSerialCommands();
        
        // æ›´æ–°ä¼‘çœ ç®¡ç† (æ¯ç§’æ‰§è¡Œä¸€æ¬¡)
        if (cycleCount % 1 == 0) {
            self->systemController->updateSleepManager();
        }
        
        // é…ç½®è‡ªåŠ¨ä¿å­˜ (æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡)
        if (cycleCount % 5 == 0) {
            if (xSemaphoreTake(self->configMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                self->systemController->saveConfigIfDirty();
                xSemaphoreGive(self->configMutex);
            }
        }
        
        // ç³»ç»Ÿç›‘æ§ (æ¯10ç§’æ‰§è¡Œä¸€æ¬¡)
        if (cycleCount % 10 == 0) {
            self->systemController->performSystemMonitoring();
            self->monitorTaskPerformance();
        }
        
        // å†…å­˜ç®¡ç† (æ¯30ç§’æ‰§è¡Œä¸€æ¬¡)
        if (cycleCount % 30 == 0) {
            self->systemController->performMemoryCleanup();
        }
        
        cycleCount++;
        
        // 1ç§’å‘¨æœŸ
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(1000));
    }
}
```

#### 2.3 SystemController å®ç°

```cpp
// SystemController.cpp
#include "SystemController.h"
#include "Logger.h"

bool SystemController::initialize() {
    LOG_I("SYS", "ç³»ç»Ÿæ§åˆ¶å™¨åˆå§‹åŒ–");
    
    // åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
    configManager = std::make_unique<ConfigManager>();
    if (!configManager->begin()) {
        LOG_E("SYS", "é…ç½®ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥");
        return false;
    }
    
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    logger = std::make_unique<Logger>();
    LoggerConfig logConfig = Logger::getDefaultConfig();
    logConfig.level = static_cast<log_level_t>(configManager->getLogLevel());
    logger->begin(logConfig);
    
    // åˆå§‹åŒ–ä¼‘çœ ç®¡ç†å™¨
    sleepManager = std::make_unique<SleepManager>();
    uint32_t sleepTimeout = configManager->getSleepTimeout();
    sleepManager->begin(sleepTimeout);
    
    // æ³¨å†Œä¼‘çœ å›è°ƒ
    sleepManager->addCallback(
        [this](void*) { this->onEnterSleep(); },
        [this](void*) { this->onExitSleep(); }
    );
    
    LOG_I("SYS", "ç³»ç»Ÿæ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ");
    return true;
}

void SystemController::processSerialCommands() {
    if (!Serial.available()) return;
    
    String command = Serial.readStringUntil('\n');
    command.trim();
    
    if (command.isEmpty()) return;
    
    // è§£æå‘½ä»¤
    handleCommand(command);
}

void SystemController::handleCommand(const String& command) {
    // åˆ†å‰²å‘½ä»¤å’Œå‚æ•°
    int spaceIndex = command.indexOf(' ');
    String cmd = (spaceIndex > 0) ? command.substring(0, spaceIndex) : command;
    String args = (spaceIndex > 0) ? command.substring(spaceIndex + 1) : "";
    
    cmd.toLowerCase();
    
    if (cmd == "help") {
        printHelp();
    } else if (cmd == "status") {
        printSystemStatus();
    } else if (cmd == "config") {
        handleConfigCommand(args);
    } else if (cmd == "test") {
        handleTestCommand(args);
    } else if (cmd == "log") {
        handleLogCommand(args);
    } else if (cmd == "piano") {
        handlePianoCommand(args);
    } else if (cmd == "reset") {
        handleResetCommand(args);
    } else {
        Serial.println("æœªçŸ¥å‘½ä»¤ï¼Œè¾“å…¥'help'æŸ¥çœ‹å¸®åŠ©");
    }
}

void SystemController::printSystemStatus() {
    Serial.println("\n=== ç³»ç»ŸçŠ¶æ€ ===");
    
    // ä»»åŠ¡çŠ¶æ€
    Serial.println("ä»»åŠ¡çŠ¶æ€:");
    printTaskStatus();
    
    // å†…å­˜ä½¿ç”¨
    Serial.printf("å †å†…å­˜: å¯ç”¨=%u, æœ€å°=%u\n", 
                  ESP.getFreeHeap(), ESP.getMinFreeHeap());
    Serial.printf("PSRAM: å¯ç”¨=%u, æ€»è®¡=%u\n", 
                  ESP.getFreePsram(), ESP.getPsramSize());
    
    // ç³»ç»Ÿä¿¡æ¯
    Serial.printf("CPUé¢‘ç‡: %u MHz\n", ESP.getCpuFreqMHz());
    Serial.printf("è¿è¡Œæ—¶é—´: %u ç§’\n", millis() / 1000);
    
    // é…ç½®çŠ¶æ€
    Serial.printf("é…ç½®æ–‡ä»¶: %s\n", configManager->isConfigDirty() ? "å·²ä¿®æ”¹" : "å·²ä¿å­˜");
    
    Serial.println("================\n");
}

void SystemController::printTaskStatus() {
    TaskStatus_t* taskStatusArray;
    UBaseType_t taskCount = uxTaskGetNumberOfTasks();
    
    taskStatusArray = static_cast<TaskStatus_t*>(pvPortMalloc(taskCount * sizeof(TaskStatus_t)));
    
    if (taskStatusArray != nullptr) {
        taskCount = uxTaskGetSystemState(taskStatusArray, taskCount, nullptr);
        
        Serial.println("ä»»åŠ¡åç§°\tçŠ¶æ€\tä¼˜å…ˆçº§\tå †æ ˆå‰©ä½™");
        
        for (UBaseType_t i = 0; i < taskCount; i++) {
            const char* taskState;
            switch (taskStatusArray[i].eCurrentState) {
                case eRunning:   taskState = "è¿è¡Œä¸­"; break;
                case eReady:     taskState = "å°±ç»ª"; break;
                case eBlocked:   taskState = "é˜»å¡"; break;
                case eSuspended: taskState = "æŒ‚èµ·"; break;
                case eDeleted:   taskState = "åˆ é™¤"; break;
                default:         taskState = "æœªçŸ¥"; break;
            }
            
            Serial.printf("%s\t%s\t%u\t%u\n",
                          taskStatusArray[i].pcTaskName,
                          taskState,
                          taskStatusArray[i].uxCurrentPriority,
                          taskStatusArray[i].usStackHighWaterMark);
        }
        
        vPortFree(taskStatusArray);
    }
}

void SystemController::performSystemMonitoring() {
    // æ£€æŸ¥å †å†…å­˜
    uint32_t freeHeap = ESP.getFreeHeap();
    if (freeHeap < MIN_FREE_HEAP_SIZE) {
        LOG_W("SYS", "å †å†…å­˜ä¸è¶³: %u bytes", freeHeap);
    }
    
    // æ£€æŸ¥ä»»åŠ¡å †æ ˆ
    checkTaskStackUsage();
    
    // æ£€æŸ¥ç³»ç»Ÿè´Ÿè½½
    checkSystemLoad();
}

void SystemController::checkTaskStackUsage() {
    // æ£€æŸ¥å„ä»»åŠ¡å †æ ˆä½¿ç”¨æƒ…å†µ
    TaskStatus_t taskStatus;
    
    // æ£€æŸ¥æŒ‰é”®ä»»åŠ¡
    if (keypadTaskHandle) {
        vTaskGetInfo(keypadTaskHandle, &taskStatus, pdTRUE, eInvalid);
        if (taskStatus.usStackHighWaterMark < MIN_STACK_REMAINING) {
            LOG_W("SYS", "æŒ‰é”®ä»»åŠ¡å †æ ˆä¸è¶³: %u words", taskStatus.usStackHighWaterMark);
        }
    }
    
    // æ£€æŸ¥æ˜¾ç¤ºä»»åŠ¡
    if (displayTaskHandle) {
        vTaskGetInfo(displayTaskHandle, &taskStatus, pdTRUE, eInvalid);
        if (taskStatus.usStackHighWaterMark < MIN_STACK_REMAINING) {
            LOG_W("SYS", "æ˜¾ç¤ºä»»åŠ¡å †æ ˆä¸è¶³: %u words", taskStatus.usStackHighWaterMark);
        }
    }
    
    // æ£€æŸ¥ç³»ç»Ÿä»»åŠ¡
    if (systemTaskHandle) {
        vTaskGetInfo(systemTaskHandle, &taskStatus, pdTRUE, eInvalid);
        if (taskStatus.usStackHighWaterMark < MIN_STACK_REMAINING) {
            LOG_W("SYS", "ç³»ç»Ÿä»»åŠ¡å †æ ˆä¸è¶³: %u words", taskStatus.usStackHighWaterMark);
        }
    }
}

void SystemController::performMemoryCleanup() {
    // æ¸…ç†è®¡ç®—å™¨å†å²è®°å½•
    if (calculatorApp) {
        calculatorApp->cleanupOldHistory();
    }
    
    // æ¸…ç†æ—¥å¿—ç¼“å†²åŒº
    if (logger) {
        logger->cleanup();
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    heap_caps_check_integrity_all(true);
}
```

#### 2.4 çº¿ç¨‹å®‰å…¨é…ç½®è®¿é—®

```cpp
// ConfigManager çº¿ç¨‹å®‰å…¨å®ç°
class ConfigManager {
private:
    mutable SemaphoreHandle_t configMutex;
    bool configDirty;
    
public:
    bool begin() {
        configMutex = xSemaphoreCreateMutex();
        configDirty = false;
        return configMutex != nullptr;
    }
    
    template<typename T>
    bool getConfigValue(const String& key, T& value) const {
        if (xSemaphoreTake(configMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            bool result = preferences.get(key, value);
            xSemaphoreGive(configMutex);
            return result;
        }
        return false;
    }
    
    template<typename T>
    bool setConfigValue(const String& key, const T& value) {
        if (xSemaphoreTake(configMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            bool result = preferences.put(key, value);
            if (result) {
                configDirty = true;
            }
            xSemaphoreGive(configMutex);
            return result;
        }
        return false;
    }
    
    void saveConfigIfDirty() {
        if (configDirty) {
            preferences.end();
            preferences.begin(CONFIG_NAMESPACE, false);
            configDirty = false;
            LOG_I("CONFIG", "é…ç½®å·²ä¿å­˜");
        }
    }
};
```

#### 2.5 æ€§èƒ½ä¼˜åŒ–å®ç°

```cpp
// å†…å­˜ä¼˜åŒ– - ä½¿ç”¨å¯¹è±¡æ± 
template<typename T, size_t PoolSize>
class ObjectPool {
private:
    std::array<T, PoolSize> pool;
    std::bitset<PoolSize> used;
    SemaphoreHandle_t mutex;
    
public:
    ObjectPool() {
        mutex = xSemaphoreCreateMutex();
    }
    
    T* acquire() {
        if (xSemaphoreTake(mutex, pdMS_TO_TICKS(10)) == pdTRUE) {
            for (size_t i = 0; i < PoolSize; ++i) {
                if (!used[i]) {
                    used[i] = true;
                    xSemaphoreGive(mutex);
                    return &pool[i];
                }
            }
            xSemaphoreGive(mutex);
        }
        return nullptr;
    }
    
    void release(T* obj) {
        if (xSemaphoreTake(mutex, pdMS_TO_TICKS(10)) == pdTRUE) {
            size_t index = obj - &pool[0];
            if (index < PoolSize) {
                used[index] = false;
            }
            xSemaphoreGive(mutex);
        }
    }
};

// ä½¿ç”¨ç¤ºä¾‹
ObjectPool<KeyEvent, 20> keyEventPool;
ObjectPool<DisplayUpdate, 10> displayUpdatePool;
```

#### 2.6 é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

```cpp
// ä»»åŠ¡å¥åº·æ£€æŸ¥
class TaskHealthMonitor {
private:
    struct TaskHealth {
        TaskHandle_t handle;
        uint32_t lastHeartbeat;
        uint32_t maxInterval;
        String name;
    };
    
    std::vector<TaskHealth> monitoredTasks;
    TaskHandle_t monitorTaskHandle;
    
public:
    void addTask(TaskHandle_t handle, const String& name, uint32_t maxInterval) {
        monitoredTasks.push_back({handle, millis(), maxInterval, name});
    }
    
    void heartbeat(TaskHandle_t handle) {
        for (auto& task : monitoredTasks) {
            if (task.handle == handle) {
                task.lastHeartbeat = millis();
                break;
            }
        }
    }
    
    void startMonitoring() {
        xTaskCreate(monitorTask, "HealthMonitor", 2048, this, 1, &monitorTaskHandle);
    }
    
    static void monitorTask(void* parameter) {
        TaskHealthMonitor* self = static_cast<TaskHealthMonitor*>(parameter);
        
        while (true) {
            uint32_t currentTime = millis();
            
            for (const auto& task : self->monitoredTasks) {
                if (currentTime - task.lastHeartbeat > task.maxInterval) {
                    LOG_E("HEALTH", "ä»»åŠ¡%sæ— å“åº”", task.name.c_str());
                    self->restartTask(task.handle, task.name);
                }
            }
            
            vTaskDelay(pdMS_TO_TICKS(5000));  // 5ç§’æ£€æŸ¥ä¸€æ¬¡
        }
    }
    
    void restartTask(TaskHandle_t handle, const String& name) {
        LOG_W("HEALTH", "é‡å¯ä»»åŠ¡: %s", name.c_str());
        // å®ç°ä»»åŠ¡é‡å¯é€»è¾‘
    }
};
```

### é˜¶æ®µ3: åŠŸèƒ½å¢å¼º (ä¼˜å…ˆçº§: ğŸŸ¢ ä½)

#### 3.1 æµ‹è¯•ç³»ç»Ÿå»ºè®¾
```cpp
// æ–°å¢ï¼šæµ‹è¯•ç®¡ç†å™¨
class TestManager {
public:
    void runAllTests();
    void runCalculatorTests();
    void runKeypadTests();
    void runDisplayTests();
    
    // é›†æˆåˆ°ä¸²å£å‘½ä»¤
    void registerCommands();
};

// ä¸²å£å‘½ä»¤æ”¯æŒ
// test all - è¿è¡Œæ‰€æœ‰æµ‹è¯•
// test calc - è¿è¡Œè®¡ç®—å™¨æµ‹è¯•
// test keypad - è¿è¡Œé”®ç›˜æµ‹è¯•
```

#### 3.2 é’¢ç´éŸ³æ•ˆå¢å¼º
```cpp
// æ–°å¢ï¼šéŸ³æ•ˆåŒ…ç»œæ§åˆ¶
class PianoSoundEngine {
    void playNoteWithEnvelope(uint8_t noteIndex, uint16_t duration);
    void playChord(const std::vector<uint8_t>& notes);
    void setVolumeEnvelope(float attack, float decay, float sustain, float release);
};
```

#### 3.3 é…ç½®ç³»ç»Ÿå¢å¼º
```cpp
// æ–°å¢ï¼šé…ç½®å¯¼å…¥å¯¼å‡º
class ConfigManager {
    bool exportConfig(const String& filename);
    bool importConfig(const String& filename);
    void resetToDefaults();
    
    // é…ç½®ç‰ˆæœ¬ç®¡ç†
    void migrateConfig(uint8_t fromVersion, uint8_t toVersion);
};
```

## ç»„ä»¶é‡è¦æ€§æœ€ç»ˆè¯„ä¼°

### æ ¸å¿ƒå¿…è¦ç»„ä»¶ (â­â­â­â­â­)
1. **CalculatorCore + CalculationEngine** - è®¡ç®—åŠŸèƒ½
2. **KeypadControl** - é”®ç›˜æ§åˆ¶å’Œé’¢ç´éŸ³æ•ˆ
3. **LVGLDisplay + LVGLCalculatorUI** - æ˜¾ç¤ºç•Œé¢
4. **ConfigManager** - é…ç½®ç®¡ç†
5. **Logger** - æ—¥å¿—ç³»ç»Ÿ (é‡æ–°è¯„ä¼°ä¸ºå¿…è¦)

### é‡è¦ç»„ä»¶ (â­â­â­â­)
1. **BacklightControl** - èƒŒå…‰æ§åˆ¶
2. **SleepManager** - ä¼‘çœ ç®¡ç†
3. **SimpleHID** - USB HIDåŠŸèƒ½
4. **NumberFormatter** - æ•°å­—æ ¼å¼åŒ–

### è¾…åŠ©ç»„ä»¶ (â­â­â­)
1. **KeyboardConfig** - é”®ç›˜é…ç½®
2. **è‡ªå®šä¹‰å­—ä½“ç³»ç»Ÿ** - è§†è§‰æ•ˆæœ

### å¼€å‘å·¥å…·ç»„ä»¶ (â­â­)
1. **FontTester** - å­—ä½“æµ‹è¯• (ä¿ç•™)
2. **TestManager** - æµ‹è¯•ç³»ç»Ÿ (å»ºè®®æ–°å¢)

## å®æ–½è·¯çº¿å›¾

### ç¬¬1-3å‘¨: ä»£ç é‡æ„ + FreeRTOSé›†æˆ (ğŸ”´ é«˜ä¼˜å…ˆçº§)
- [x] åˆ†æç°æœ‰æ¶æ„é—®é¢˜
- [ ] **é˜¶æ®µ1A**: FreeRTOSä»»åŠ¡ç³»ç»Ÿè®¾è®¡
  - [ ] åˆ›å»ºTaskManagerç±»å’Œä»»åŠ¡ç®¡ç†æ¶æ„
  - [ ] å®ç°æŒ‰é”®ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§ï¼Œ10mså‘¨æœŸ)
  - [ ] å®ç°æ˜¾ç¤ºä»»åŠ¡ (ä¸­ä¼˜å…ˆçº§ï¼Œ20mså‘¨æœŸ)
  - [ ] å®ç°ç³»ç»Ÿä»»åŠ¡ (ä½ä¼˜å…ˆçº§ï¼Œ1så‘¨æœŸ)
- [ ] **é˜¶æ®µ1B**: ä»£ç ç»“æ„é‡æ„
  - [ ] é‡æ„main.cppï¼Œå¼•å…¥TaskManager
  - [ ] åˆ›å»ºSystemControllerå’ŒCalculatorApplication
  - [ ] å®ç°ä»»åŠ¡é—´é€šä¿¡æœºåˆ¶ (é˜Ÿåˆ—ã€ä¿¡å·é‡)
  - [ ] çº¿ç¨‹å®‰å…¨çš„é…ç½®ç®¡ç†
- [ ] **é˜¶æ®µ1C**: åŸºç¡€åŠŸèƒ½éªŒè¯
  - [ ] æµ‹è¯•æŒ‰é”®å“åº”å’ŒLEDæ•ˆæœ
  - [ ] æµ‹è¯•æ˜¾ç¤ºæ›´æ–°å’Œè®¡ç®—åŠŸèƒ½
  - [ ] æµ‹è¯•é’¢ç´éŸ³æ•ˆåœ¨å¤šä»»åŠ¡ç¯å¢ƒä¸‹çš„è¡¨ç°
  - [ ] éªŒè¯ç³»ç»Ÿç¨³å®šæ€§å’Œä»»åŠ¡è°ƒåº¦

### ç¬¬4-5å‘¨: æ€§èƒ½ä¼˜åŒ–å’ŒåŠŸèƒ½å¢å¼º (ğŸŸ¡ ä¸­ä¼˜å…ˆçº§)
- [ ] **é˜¶æ®µ2A**: æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
  - [ ] å®ç°ä»»åŠ¡æ€§èƒ½ç›‘æ§
  - [ ] ä¼˜åŒ–å†…å­˜ä½¿ç”¨å’Œå¯¹è±¡æ± 
  - [ ] å®ç°åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´
  - [ ] å»ºç«‹çœ‹é—¨ç‹—å’Œå¥åº·æ£€æŸ¥æœºåˆ¶
- [ ] **é˜¶æ®µ2B**: æµ‹è¯•ç³»ç»Ÿå»ºè®¾
  - [ ] å»ºç«‹åˆ†å¸ƒå¼æµ‹è¯•æ¡†æ¶
  - [ ] å®ç°æ ¸å¿ƒç»„ä»¶å•å…ƒæµ‹è¯•
  - [ ] é›†æˆå­—ä½“æµ‹è¯•åˆ°æµ‹è¯•ç³»ç»Ÿ
  - [ ] å»ºç«‹æŒç»­é›†æˆæµ‹è¯•æµç¨‹
- [ ] **é˜¶æ®µ2C**: é’¢ç´éŸ³æ•ˆå¢å¼º
  - [ ] å®ç°é«˜æ€§èƒ½éŸ³æ•ˆå¼•æ“
  - [ ] æ·»åŠ å’Œå¼¦æ’­æ”¾åŠŸèƒ½
  - [ ] ä¼˜åŒ–éŸ³æ•ˆåŒ…ç»œæ§åˆ¶
  - [ ] å®ç°è‡ªå®šä¹‰éŸ³é˜¶é…ç½®

### ç¬¬6å‘¨: ç³»ç»Ÿé›†æˆå’Œæ–‡æ¡£ (ğŸŸ¢ ä½ä¼˜å…ˆçº§)
- [ ] **é˜¶æ®µ3A**: å…¨é¢æµ‹è¯•
  - [ ] å¤šä»»åŠ¡ç¯å¢ƒä¸‹çš„å‹åŠ›æµ‹è¯•
  - [ ] é•¿æœŸç¨³å®šæ€§æµ‹è¯•
  - [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•
  - [ ] ç”¨æˆ·ä½“éªŒæµ‹è¯•
- [ ] **é˜¶æ®µ3B**: æ–‡æ¡£å’Œå·¥å…·
  - [ ] æ›´æ–°æŠ€æœ¯æ–‡æ¡£
  - [ ] å®Œå–„ä¸²å£å‘½ä»¤ç³»ç»Ÿ
  - [ ] åˆ›å»ºå¼€å‘è€…æŒ‡å—
  - [ ] æ€§èƒ½è°ƒä¼˜å»ºè®®

### å…³é”®é‡Œç¨‹ç¢‘æ£€æŸ¥ç‚¹

#### æ£€æŸ¥ç‚¹1 (ç¬¬2å‘¨æœ«): FreeRTOSåŸºç¡€æ¡†æ¶
- [ ] ä¸‰ä¸ªæ ¸å¿ƒä»»åŠ¡æˆåŠŸè¿è¡Œ
- [ ] ä»»åŠ¡é—´é€šä¿¡æ­£å¸¸å·¥ä½œ
- [ ] åŸºæœ¬çš„æŒ‰é”®å’Œæ˜¾ç¤ºåŠŸèƒ½æ­£å¸¸
- [ ] ç³»ç»Ÿæ— æ­»é”å’Œå´©æºƒ

#### æ£€æŸ¥ç‚¹2 (ç¬¬4å‘¨æœ«): å®Œæ•´åŠŸèƒ½éªŒè¯
- [ ] æ‰€æœ‰åŸæœ‰åŠŸèƒ½åœ¨æ–°æ¶æ„ä¸‹æ­£å¸¸å·¥ä½œ
- [ ] é’¢ç´éŸ³æ•ˆå’ŒLEDæ•ˆæœæµç•…è¿è¡Œ
- [ ] é…ç½®ç³»ç»Ÿçº¿ç¨‹å®‰å…¨è¿è¡Œ
- [ ] æ€§èƒ½ç›‘æ§ç³»ç»Ÿæ­£å¸¸å·¥ä½œ

#### æ£€æŸ¥ç‚¹3 (ç¬¬6å‘¨æœ«): æœ€ç»ˆäº¤ä»˜
- [ ] å®Œæ•´çš„æµ‹è¯•è¦†ç›–
- [ ] æ€§èƒ½è¾¾åˆ°ä¼˜åŒ–ç›®æ ‡
- [ ] æ–‡æ¡£å®Œæ•´ä¸”å‡†ç¡®
- [ ] ä»£ç è´¨é‡ç¬¦åˆæ ‡å‡†

### é£é™©æ§åˆ¶å’Œåº”æ€¥æ–¹æ¡ˆ

#### ä¸»è¦é£é™©ç‚¹
1. **FreeRTOSé›†æˆå¤æ‚åº¦**: å¯èƒ½å½±å“ç°æœ‰åŠŸèƒ½ç¨³å®šæ€§
2. **ä»»åŠ¡é—´åŒæ­¥é—®é¢˜**: å¯èƒ½å¯¼è‡´æ­»é”æˆ–æ•°æ®ç«äº‰
3. **æ€§èƒ½å›é€€**: æ–°æ¶æ„å¯èƒ½å½±å“å“åº”é€Ÿåº¦
4. **å†…å­˜ä½¿ç”¨å¢åŠ **: å¤šä»»åŠ¡å¯èƒ½å¢åŠ å†…å­˜å¼€é”€

#### åº”æ€¥æ–¹æ¡ˆ
1. **æ¸è¿›å¼è¿ç§»**: å…ˆè¿ç§»éå…³é”®ä»»åŠ¡ï¼Œé€æ­¥æ‰©å±•
2. **å›æ»šæœºåˆ¶**: ä¿æŒå½“å‰ç‰ˆæœ¬ä½œä¸ºåå¤‡
3. **æ€§èƒ½ç›‘æ§**: å®æ—¶ç›‘æ§å…³é”®æŒ‡æ ‡
4. **åˆ†é˜¶æ®µæµ‹è¯•**: æ¯ä¸ªé˜¶æ®µéƒ½è¿›è¡Œå……åˆ†æµ‹è¯•

## é¢„æœŸæ”¹è¿›æ•ˆæœ

### æ€§èƒ½æ”¹è¿›
- **å¯åŠ¨æ—¶é—´**: ä»3ç§’ä¼˜åŒ–åˆ°1.5ç§’
- **å†…å­˜ä½¿ç”¨**: å‡å°‘15-20%çš„RAMå ç”¨
- **å“åº”æ€§**: æŒ‰é”®å“åº”æ—¶é—´å°äº10ms

### ä»£ç è´¨é‡æ”¹è¿›
- **å¯ç»´æŠ¤æ€§**: æ¨¡å—åŒ–è®¾è®¡ï¼ŒèŒè´£åˆ†ç¦»
- **å¯æµ‹è¯•æ€§**: å®Œæ•´çš„æµ‹è¯•ç³»ç»Ÿ
- **å¯æ‰©å±•æ€§**: æ¸…æ™°çš„æ¶æ„è¾¹ç•Œ

### ç”¨æˆ·ä½“éªŒæ”¹è¿›
- **ç¨³å®šæ€§**: å®Œå–„çš„æ—¥å¿—ç³»ç»Ÿå’Œé”™è¯¯å¤„ç†
- **ä¸ªæ€§åŒ–**: ä¿æŒä¸°å¯Œçš„é…ç½®é€‰é¡¹
- **åŠŸèƒ½å®Œæ•´**: ä¿ç•™æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½

## ç»“è®º

ç»è¿‡é‡æ–°è¯„ä¼°ï¼ŒPawCounteré¡¹ç›®çš„å½“å‰æ¶æ„åŸºæœ¬åˆç†ï¼Œä¸»è¦é—®é¢˜é›†ä¸­åœ¨ä»£ç ç»„ç»‡å’Œæ¨¡å—åŒ–æ–¹é¢ã€‚å…³é”®å‘ç°åŒ…æ‹¬ï¼š

1. **æ—¥å¿—ç³»ç»Ÿæ˜¯å¿…è¦çš„**: å¯¹äºé¢å‘æå®¢ç”¨æˆ·çš„äº§å“ï¼Œå®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿæ˜¯å¿…éœ€åŠŸèƒ½
2. **é’¢ç´éŸ³æ•ˆæ˜¯æ ¸å¿ƒç«äº‰åŠ›**: è¿™æ˜¯äº§å“çš„ç‹¬ç‰¹å–ç‚¹ï¼Œä¸åº”è¢«ç®€åŒ–
3. **é…ç½®ç³»ç»Ÿç¬¦åˆç”¨æˆ·éœ€æ±‚**: TOCç”¨æˆ·éœ€è¦ç»†è‡´çš„ä¸ªæ€§åŒ–è®¾ç½®
4. **æµ‹è¯•ç³»ç»Ÿéœ€è¦å»ºç«‹**: æé«˜ä»£ç è´¨é‡å’Œç”¨æˆ·ä¿¡å¿ƒ

**æ¨èçš„ä¼˜åŒ–ç­–ç•¥**:
- ä¿æŒç°æœ‰åŠŸèƒ½çš„å®Œæ•´æ€§
- é‡ç‚¹è¿›è¡Œä»£ç é‡æ„å’Œæ¨¡å—åŒ–
- å»ºç«‹å®Œå–„çš„æµ‹è¯•ç³»ç»Ÿ
- ä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ

è¿™ç§å¹³è¡¡çš„æ–¹æ³•æ—¢æ»¡è¶³äº†ç›®æ ‡ç”¨æˆ·çš„éœ€æ±‚ï¼Œåˆæå‡äº†ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œäº§å“çš„ç«äº‰åŠ›ã€‚

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2024å¹´7æœˆ10æ—¥  
**åˆ†æå·¥å…·**: Claude Code Architecture Analysis  
**åˆ†ææ·±åº¦**: æ·±åº¦ä»£ç å®¡æŸ¥ + ç”¨æˆ·éœ€æ±‚åˆ†æ + äº§å“å®šä½è¯„ä¼°  
**å»ºè®®ç­‰çº§**: äº§å“çº§ä¼˜åŒ–å»ºè®® (é¢å‘TOCé”®ç›˜åœˆå­ç”¨æˆ·)